//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template <typename T> Quaternion<T>::Quaternion(T x, T y, T z, T w)
	{
    	this->x() = x;
    	this->y() = y;
    	this->z() = z;
    	this->w() = w;
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector4<T> const& data) : _data(data)
	{
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector3<T> const& axis, T angle)
	{
    	fromAngleAxis(axis, angle);
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector3<T> const& angles)
	{
    	fromAngles(angles);
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector3<T> start, Vector3<T> dest)
	{
		fromVectors(start, dest);
	}
    
    template <typename T> Quaternion<T>::Quaternion(Quaternion<T> const& other)
    		: Quaternion(other.x(), other.y(), other.z(), other.w())
    {
    }
    
    template <typename T> T& Quaternion<T>::x()
	{
	    return _data[0];
	}
    
    template <typename T> const T& Quaternion<T>::x() const
	{
		return _data[0];
	}

    template <typename T> T& Quaternion<T>::y()
	{
	    return _data[1];
	}
    
    template <typename T> const T& Quaternion<T>::y() const
	{
	    return _data[1];
	}

    template <typename T> T& Quaternion<T>::z()
	{
		return _data[2];
	}
    
    template <typename T> const T& Quaternion<T>::z() const
	{
		return _data[2];
	}

    template <typename T> T& Quaternion<T>::w()
	{
	    return _data[3];
	}
    
    template <typename T> const T& Quaternion<T>::w() const
	{
	    return _data[3];
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::fromAngleAxis(Vector3<T> const& axis, T angle)
	{
    	x() = axis.x() * sin(angle / 2);
		y() = axis.y() * sin(angle / 2);
		z() = axis.z() * sin(angle / 2);
		w() = cos(angle / 2);
		
		return *this;
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::fromAngles(Vector3<T> const& angles)
	{
    	float cosX_2 = cos(angles[0] / 2);
		float cosY_2 = cos(angles[1] / 2);
		float cosZ_2 = cos(angles[2] / 2);
		float sinX_2 = sin(angles[0] / 2);
		float sinY_2 = sin(angles[1] / 2);
		float sinZ_2 = sin(angles[2] / 2);
		x() = cosZ_2 * cosY_2 * sinX_2 - sinZ_2 * sinY_2 * cosX_2;
		y() = cosZ_2 * sinY_2 * cosX_2 + sinZ_2 * cosY_2 * sinX_2;
		z() = sinZ_2 * cosY_2 * cosX_2 - cosZ_2 * sinY_2 * sinX_2;
		w() = cosZ_2 * cosY_2 * cosX_2 + sinZ_2 * sinY_2 * sinX_2;
		
		return *this;
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::fromVectors(Vector3<T> start, Vector3<T> dest)
	{
    	start.normalize();
		dest.normalize();
	 
		float cosTheta = start * dest;
		Vector3<T> axis;
	 
		// Check if vectors are in opposite direction
		if (dbgl::isSimilar(cosTheta, -1))
		{
			// Guess a random axis
			axis = start.getCrossProduct(Vector3<T>(1, 0, 0));
			if (dbgl::isSimilar(axis.getSquaredLength(), 0)) // Dammit!
				axis = start.getCrossProduct(Vector3<T>(0, 1, 0));
			axis.normalize();
			// Initialize
			fromAngleAxis(axis, pi_2());
		}
		// If not parallel everything's easier
		axis = start.getCrossProduct(dest);
		T s = std::sqrt((1 + cosTheta) * 2);
	 
		x() = axis.x() * 1 / s;
		y() = axis.y() * 1 / s;
		z() = axis.z() * 1 / s;
		w() = s * 0.5;
		
		return *this;
	}
    
    template <typename T> bool Quaternion<T>::isSimilar(Quaternion<T> const& other, double precision) const
	{
    	if(precision == 0)
    		return _data == other._data;
    	else
    	{
			for(int i = 0; i < _data.getDimension(); i++)
			{
				if(!dbgl::isSimilar(_data[i], other._data[i], precision))
					return false;
			}
    	}
	    return true;
	}
    
    template <typename T> bool Quaternion<T>::isSimilarRot(Quaternion<T> const& other, double precision) const
	{
    	return (dbgl::isSimilar(dot(other) - 1, 0, precision));
	}
    
    template <typename T> bool Quaternion<T>::isUnit() const
	{
    	return getSquaredLength() == 1;
	}
    
    template <typename T> Matrix4x4<T> Quaternion<T>::getMatrix() const
	{
    	Matrix4x4<T> mat;
	    mat[0][0] = 1 - 2 * (y() * y() + z() * z()); 
	    mat[0][1] = 2 * (x() * y() + w() * z());
	    mat[0][2] = 2 * (x() * z() - w() * y());
	    mat[0][3] = 0;
	    mat[1][0] = 2 * (x() * y() - w() * z());
	    mat[1][1] = 1 - 2 * (x() * x() + z() * z());
	    mat[1][2] = 2 * (y() * z() + w() * x());
	    mat[1][3] = 0;
	    mat[2][0] = 2 * (x() * z() + w() * y());
	    mat[2][1] = 2 * (y() * z()-w() * x());
	    mat[2][2] = 1 - 2 * (x() * x() + y() * y());
	    mat[2][3] = 0;
	    mat[3][0] = 0;
	    mat[3][1] = 0;
	    mat[3][2] = 0;
	    mat[3][3] = 1;
	    return mat;
	}
    
    template <typename T> Vector3<T> Quaternion<T>::getAngles() const
	{
		Vector3<T> angles;
		angles[0] = atan2(2 * (y() * z() + w() * x()),
				w() * w() - x() * x() - y() * y() + z() * z());
		angles[1] = asin(-2 * (x() * z() - w() * y()));
		angles[2] = atan2(2 * (x() * y() + w() * z()),
				w() * w() + x() * x() - y() * y() - z() * z());
		return angles;
	}
    
    template <typename T> T Quaternion<T>::getSquaredLength() const
    {
    	return _data.getSquaredLength();
    }

    template <typename T>T Quaternion<T>::getLength() const
	{
		return _data.getLength();
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::getNormalized() const
	{
	    return Quaternion<T>(*this).normalize();
	}

    template <typename T> Quaternion<T>& Quaternion<T>::normalize()
	{
	    _data.normalize();
	    return *this;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::getConjugated() const
	{
	    return Quaternion<T>(*this).conjugate();
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::conjugate()
	{
	    x() = -x();
	    y() = -y();
	    z() = -z();
	    return *this;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::getInverted() const
	{
    	return Quaternion<T>(*this).invert();
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::invert()
	{
    	return conjugate() /= getSquaredLength();
	}
    
    template <typename T> const T Quaternion<T>::dot(Quaternion<T> const& rhs) const
	{
		return _data * rhs._data;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::cross(Quaternion<T> const& rhs) const
	{
	    return (*this) * rhs;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::lerp(Quaternion<T> const& other, T factor) const
	{
    	// Check if factor is valid
    	if(factor < 0 || factor > 1)
    	{
    		LOG->warning("Quaternion lerp factor out of range!");
    		factor = (factor < 0) ? 0 : 1;
    	}
    	return (*this) * (1 - factor) + (other * factor);
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::slerp(Quaternion<T> const& other, T factor) const
	{
    	auto copy = other;
		T dotProd = dot(copy);
		// Always use shortest path, so invert one quaternion if dotProd < 0
		if (dotProd < 0)
		{
			copy = -copy;
			dotProd = -dotProd;
		}
		// If angle is small use linear interpolation to avoid sin(1) == 0
		if(dotProd > 1 - std::numeric_limits<T>::epsilon())
		{
			return Quaternion<T>(w() + factor * (copy.w() - w()),
					x() + factor * (copy.x() - x()),
					y() + factor * (copy.y() - y()),
					z() + factor * (copy.z() - z()));
		}
		else
		{
			T angle = std::acos(dotProd);
			return ((*this) * std::sin((1 - factor) * angle) +
					copy * std::sin(factor * angle)) / std::sin(angle);
		}
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::rotateTowards(Quaternion<T> other, T maxAngle)
	{
		// Prevent division by 0
		if(maxAngle < 2 * std::numeric_limits<T>::epsilon())
			return *this;
	 
		float cosTheta = dot(other);
		
		// Already equal?
		if(cosTheta > 1 - std::numeric_limits<T>::epsilon())
		{
			_data = other._data;
			return *this;
		}
	 
		// Force shortest path
		if (cosTheta < 0)
		{
			(*this) *= -1;
			cosTheta *= -1;
		}
	 
		float angle = std::acos(cosTheta);
	 
		// Already there?
		if (angle < maxAngle)
		{
			_data = other._data;
			return *this;
		}
	 
		float phase = maxAngle / angle;
		angle = maxAngle;
	 
		*this = ((*this) * std::sin((1 - phase) * angle) + other * std::sin(phase * angle)) /
				std::sin(angle);
		
		return normalize();
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator=(Quaternion<T> const& rhs)
    {
		if (*this != rhs)
		{ 
			for(int i = 0; i < _data.getDimension(); i++)
				_data[i] = rhs._data[i];
		} 
		return *this;
    }
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator+(Quaternion<T> const& rhs) const
    {
    	return Quaternion<T>(_data + rhs._data);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator+=(Quaternion<T> const& rhs)
	{
	    _data += rhs._data;
	    return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator-(Quaternion<T> const& rhs) const
    {
    	return Quaternion<T>(_data - rhs._data);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator-=(Quaternion<T> const& rhs)
	{
    	_data -= rhs._data;
    	return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator*(Quaternion<T> const& rhs) const
    {
    	return (Quaternion<T>(*this) *= rhs);
    }
    
    template <typename T> const Vector3<T> Quaternion<T>::operator*(Vector3<T> const& rhs) const
	{
    	Vector3<T> cross1, cross2;
		auto quatVec = Vector3<T>(x(), y(), z());
		cross1 = quatVec.getCrossProduct(rhs);
		cross2 = quatVec.getCrossProduct(cross1);
		cross1 *= (2 * w()); 
		cross2 *= 2;
		return rhs + cross1 + cross2;
	}
    
    template <typename T> const Vector4<T> Quaternion<T>::operator*(Vector4<T> const& rhs) const
    {
    	Vector4<T> cross1, cross2;
    	auto quatVec = Vector4<T>(x(), y(), z());
    	cross1 = quatVec.getCrossProduct(rhs);
    	cross2 = quatVec.getCrossProduct(cross1);
		cross1 *= (2 * w()); 
		cross2 *= 2;
		return rhs + cross1 + cross2;
    }
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator*(T const& rhs) const
    {
    	return Quaternion<T>(_data * rhs);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator*=(Quaternion<T> const& rhs)
	{
    	auto temp = _data;
    	x() = temp.w() * rhs.x() + temp.x() * rhs.w() + temp.y() * rhs.z() - temp.z() * rhs.y();
    	y() = temp.w() * rhs.y() + temp.y() * rhs.w() + temp.z() * rhs.x() - temp.x() * rhs.z();
    	z() = temp.w() * rhs.z() + temp.z() * rhs.w() + temp.x() * rhs.y() - temp.y() * rhs.x();
    	w() = temp.w() * rhs.w() - temp.x() * rhs.x() - temp.y() * rhs.y() - temp.z() * rhs.z();
    	return *this;
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator*=(T const& rhs)
	{
	    _data *= rhs;
	    return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator/(T const& rhs) const
    {
    	return (Quaternion<T>(*this)/=rhs);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator/=(T const& rhs)
	{
	    _data /= rhs;
	    return *this;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::operator-() const
    {
    	return Quaternion<T>(-_data);
    }
    
    template <typename T> bool Quaternion<T>::operator==(Quaternion<T> const& rhs) const
	{
	    return _data == rhs._data;
	}
    
    template <typename T> bool Quaternion<T>::operator!=(Quaternion<T> const& rhs) const
	{
	    return !((*this)==rhs);
	}
    
    template <typename T> Quaternion<T>::operator Matrix4x4<T>() const
	{
	    return getMatrix();
	}
}