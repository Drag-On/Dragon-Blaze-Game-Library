//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template <typename T> Quaternion<T>::Quaternion(T x, T y, T z, T w)
	{
    	_data[0] = x;
    	_data[1] = y;
    	_data[2] = z;
    	_data[3] = w;
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector4<T> data) : _data(data)
	{
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector3<T> axis, T angle)
	{
    	_data[0] = axis[0] * sin(angle / 2);
    	_data[1] = axis[1] * sin(angle / 2);
    	_data[2] = axis[2] * sin(angle / 2);
    	_data[3] = cos(angle / 2);
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector3<T> angles)
	{
    	float cosX_2 = cos(angles[0] / 2);
		float cosY_2 = cos(angles[1] / 2);
		float cosZ_2 = cos(angles[2] / 2);
		float sinX_2 = sin(angles[0] / 2);
		float sinY_2 = sin(angles[1] / 2);
		float sinZ_2 = sin(angles[2] / 2);
		_data[0] = cosZ_2 * cosY_2 * sinX_2 - sinZ_2 * sinY_2 * cosX_2;
		_data[1] = cosZ_2 * sinY_2 * cosX_2 + sinZ_2 * cosY_2 * sinX_2;
		_data[2] = sinZ_2 * cosY_2 * cosX_2 - cosZ_2 * sinY_2 * sinX_2;
		_data[3] = cosZ_2 * cosY_2 * cosX_2 + sinZ_2 * sinY_2 * sinX_2;
	}
    
    template <typename T> Quaternion<T>::Quaternion(const Quaternion<T>& other) : Quaternion(other[0], other[1], other[2], other[3])
    {
    }
    
    template <typename T> T& Quaternion<T>::x()
	{
	    return _data[0];
	}
    
    template <typename T> const T& Quaternion<T>::x() const
	{
		return _data[0];
	}

    template <typename T> T& Quaternion<T>::y()
	{
	    return _data[1];
	}
    
    template <typename T> const T& Quaternion<T>::y() const
	{
	    return _data[1];
	}

    template <typename T> T& Quaternion<T>::z()
	{
		return _data[2];
	}
    
    template <typename T> const T& Quaternion<T>::z() const
	{
		return _data[2];
	}

    template <typename T> T& Quaternion<T>::w()
	{
	    return _data[3];
	}
    
    template <typename T> const T& Quaternion<T>::w() const
	{
	    return _data[3];
	}
    
    template <typename T> bool Quaternion<T>::isSimilar(Quaternion const& other, double precision) const
	{
    	if(precision == 0)
    		return _data == other._data;
    	else
    	{
			for(int i = 0; i < _data.getDimension(); i++)
			{
				if(!dbgl::isSimilar(_data[i], other._data[i], precision))
					return false;
			}
    	}
	    return true;
	}
    
    template <typename T> bool Quaternion<T>::isUnit() const
	{
    	return getSquaredLength() == 1;
	}
    
    template <typename T> Matrix4x4<T> Quaternion<T>::getMatrix() const
	{
    	Matrix4x4<T> mat;
	    mat[0][0] = 1 - 2 * (y() * y() + z() * z()); 
	    mat[0][1] = 2 * (x() * y() + w() * z());
	    mat[0][2] = 2 * (x() * z() - w() * y());
	    mat[0][3] = 0;
	    mat[1][0] = 2 * (x() * y() - w() * z());
	    mat[1][1] = 1 - 2 * (x() * x() + z() * z());
	    mat[1][2] = 2 * (y() * z() + w() * x());
	    mat[1][3] = 0;
	    mat[2][0] = 2 * (x() * z() + w() * y());
	    mat[2][1] = 2 * (y() * z()-w() * x());
	    mat[2][2] = 1 - 2 * (x() * x() + y() * y());
	    mat[2][3] = 0;
	    mat[3][0] = 0;
	    mat[3][1] = 0;
	    mat[3][2] = 0;
	    mat[3][3] = 1;
	    return mat;
	}
    
    template <typename T> Vector3<T> Quaternion<T>::getAngles() const
	{
		Vector3<T> angles;
		angles[0] = atan2(2 * (y() * z() + w() * x()),
				w() * w() - x() * x() - y() * y() + z() * z());
		angles[1] = asin(-2 * (x() * z() - w() * y()));
		angles[2] = atan2(2 * (x() * y() + w() * z()),
				w() * w() + x() * x() - y() * y() - z() * z());
		return angles;
	}
    
    template <typename T> T Quaternion<T>::getSquaredLength() const
    {
    	return _data.getSquaredLength();
    }

    template <typename T>T Quaternion<T>::getLength() const
	{
		return _data.getLength();
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::getNormalized() const
	{
	    return Quaternion<T>(*this).normalize();
	}

    template <typename T> Quaternion<T>& Quaternion<T>::normalize()
	{
	    _data.normalize();
	    return *this;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::getConjugated() const
	{
	    return Quaternion<T>(*this).conjugate();
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::conjugate()
	{
	    x() = -x();
	    y() = -y();
	    z() = -z();
	    return *this;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::getInverted() const
	{
    	return Quaternion<T>(*this).invert();
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::invert()
	{
    	return conjugate() /= getSquaredLength();
	}
    
    template <typename T> const T Quaternion<T>::dot(Quaternion<T> const& rhs) const
	{
		return _data * rhs._data;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::lerp(Quaternion<T> const& other, T factor) const
	{
    	// Check if factor is valid
    	if(factor < 0 || factor > 1)
    	{
    		LOG->warning("Quaternion lerp factor out of range!");
    		factor = (factor < 0) ? 0 : 1;
    	}
    	return (*this) * (1 - factor) + (other * factor);
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::slerp(Quaternion<T> const& other, T factor) const
	{
    	auto copy = other;
		T dotProd = dot(copy);
		// Always use shortest path, so invert one quaternion if dotProd < 0
		if (dotProd < 0)
		{
			copy = -copy;
			dotProd = -dotProd;
		}
		// If angle is small use linear interpolation to avoid sin(1) == 0
		if(dotProd > 1 - std::numeric_limits<T>::epsilon())
		{
			return Quaternion<T>(w() + factor * (copy.w() - w()),
					x() + factor * (copy.x() - x()),
					y() + factor * (copy.y() - y()),
					z() + factor * (copy.z() - z()));
		}
		else
		{
			T angle = std::acos(dotProd);
			return ((*this) * std::sin((1 - factor) * angle) +
					copy * std::sin(factor * angle)) / std::sin(angle);
		}
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator=(Quaternion<T> const& rhs)
    {

		if (*this != rhs)
		{ 
			for(int i = 0; i < _data.getDimension(); i++)
				_data[i] = rhs[i];
		} 
		return *this;
    }
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator+(Quaternion<T> const& rhs) const
    {
    	return Quaternion<T>(_data + rhs._data);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator+=(Quaternion<T> const& rhs)
	{
	    _data += rhs._data;
	    return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator-(Quaternion<T> const& rhs) const
    {
    	return Quaternion<T>(_data - rhs._data);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator-=(Quaternion<T> const& rhs)
	{
    	_data -= rhs._data;
    	return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator*(Quaternion<T> const& rhs) const
    {
    	return (Quaternion<T>(*this) *= rhs);
    }
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator*(T const& rhs) const
    {
    	return Quaternion<T>(_data * rhs);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator*=(Quaternion<T> const& rhs)
	{
    	auto temp = _data;
    	x() = temp[3] * rhs.w() - temp[0] * rhs.x() - temp[1] * rhs.y() - temp[2] * rhs.z();
    	y() = temp[3] * rhs.x() + temp[0] * rhs.w() + temp[1] * rhs.z() - temp[2] * rhs.y();
    	z() = temp[3] * rhs.y() + temp[1] * rhs.w() + temp[2] * rhs.x() - temp[0] * rhs.z();
    	w() = temp[3] * rhs.z() + temp[2] * rhs.w() + temp[0] * rhs.y() - temp[1] * rhs.x();
    	return *this;
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator*=(T const& rhs)
	{
	    _data *= rhs;
	    return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator/(T const& rhs) const
    {
    	return (Quaternion<T>(*this)/=rhs);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator/=(T const& rhs)
	{
	    _data /= rhs;
	    return *this;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::operator-() const
    {
    	return Quaternion<T>(-_data);
    }
    
    template <typename T> bool Quaternion<T>::operator==(Quaternion<T> const& rhs) const
	{
	    return _data == rhs._data;
	}
    
    template <typename T> bool Quaternion<T>::operator!=(Quaternion<T> const& rhs) const
	{
	    return !((*this)==rhs);
	}
    
    template <typename T> T& Quaternion<T>::operator[](std::size_t const& index)
    {
    	return _data[index];
    }
    
    template <typename T> const T& Quaternion<T>::operator[](std::size_t const& index) const
    {
    	return _data[index];
    }
    
    template <typename T> Quaternion<T>::operator Matrix4x4<T>() const
	{
	    return getMatrix();
	}
}