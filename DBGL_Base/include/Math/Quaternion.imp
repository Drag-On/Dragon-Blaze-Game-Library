//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template <typename T> Quaternion<T>::Quaternion(T x, T y, T z, T w)
	{
    	_data[0] = x;
    	_data[1] = y;
    	_data[2] = z;
    	_data[3] = w;
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector4<T> data) : _data(data)
	{
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector3<T> axis, T angle)
	{
    	_data[0] = axis[0] * sin(angle / 2);
    	_data[1] = axis[1] * sin(angle / 2);
    	_data[2] = axis[2] * sin(angle / 2);
    	_data[3] = cos(angle / 2);
	}
    
    template <typename T> Quaternion<T>::Quaternion(Vector3<T> angles)
	{
    	float cosX_2 = cos(angles[0] / 2);
		float cosY_2 = cos(angles[1] / 2);
		float cosZ_2 = cos(angles[2] / 2);
		float sinX_2 = sin(angles[0] / 2);
		float sinY_2 = sin(angles[1] / 2);
		float sinZ_2 = sin(angles[2] / 2);
		_data[0] = cosZ_2 * cosY_2 * sinX_2 - sinZ_2 * sinY_2 * cosX_2;
		_data[1] = cosZ_2 * sinY_2 * cosX_2 + sinZ_2 * cosY_2 * sinX_2;
		_data[2] = sinZ_2 * cosY_2 * cosX_2 - cosZ_2 * sinY_2 * sinX_2;
		_data[3] = cosZ_2 * cosY_2 * cosX_2 + sinZ_2 * sinY_2 * sinX_2;
	}
    
    template <typename T> bool Quaternion<T>::isSimilar(Quaternion const& other, double precision) const
	{
    	if(precision == 0)
    		return _data == other._data;
    	else
    	{
			for(int i = 0; i < _data.getDimension(); i++)
			{
				if(!dbgl::isSimilar(_data[i], other._data[i], precision))
					return false;
			}
    	}
	    return true;
	}
    
    template <typename T> bool Quaternion<T>::isUnit()
	{
    	return (_data[0] == (_data[1] == (_data[2] == 0)) && _data[3] == 1);
	}
    
    template <typename T> Matrix4x4<T> Quaternion<T>::getMatrix()
	{
    	Matrix4x4<T> mat;
	    mat[0][0] = 1 - 2 * (_data[1] * _data[1] + _data[2] * _data[2]); 
	    mat[0][1] = 2 * (_data[0] * _data[1] + _data[3] * _data[2]);
	    mat[0][2] = 2 * (_data[0] * _data[2] - _data[3] * _data[1]);
	    mat[0][3] = 0;
	    mat[1][0] = 2 * (_data[0] * _data[1] - _data[3] * _data[2]);
	    mat[1][1] = 1 - 2 * (_data[0] * _data[0] + _data[2] * _data[2]);
	    mat[1][2] = 2 * (_data[1] * _data[2] + _data[3] * _data[0]);
	    mat[1][3] = 0;
	    mat[2][0] = 2 * (_data[0] * _data[2] + _data[3] * _data[1]);
	    mat[2][1] = 2 * (_data[1] * _data[2]-_data[3] * _data[0]);
	    mat[2][2] = 1 - 2 * (_data[0] * _data[0] + _data[1] * _data[1]);
	    mat[2][3] = 0;
	    mat[3][0] = 0;
	    mat[3][1] = 0;
	    mat[3][2] = 0;
	    mat[3][3] = 1;
	    return mat;
	}
    
    template <typename T> Vector3<T> Quaternion<T>::getAngles()
	{
		Vector3<T> angles;
		angles[0] = atan2(2 * (_data[1] * _data[2] + _data[3] * _data[0]),
				_data[3] * _data[3] - _data[0] * _data[0] - _data[1] * _data[1] + _data[2] * _data[2]);
		angles[1] = asin(-2 * (_data[0] * _data[2] - _data[3] * _data[1]));
		angles[2] = atan2(2 * (_data[0] * _data[1] + _data[3] * _data[2]),
				_data[3] * _data[3] + _data[0] * _data[0] - _data[1] * _data[1] - _data[2] * _data[2]);
		return angles;
	}
    
    template <typename T> const T Quaternion<T>::dot(Quaternion<T> const& rhs) const
	{
		return _data * rhs._data;
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator=(Quaternion<T> const& rhs)
    {
	    _data[0] = rhs._data[0];
	    _data[1] = rhs._data[1];
	    _data[2] = rhs._data[2];
	    _data[3] = rhs._data[3];
	    return *this;
    }
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator+(Quaternion<T> const& rhs) const
    {
    	return Quaternion<T>(_data + rhs._data);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator+=(Quaternion<T> const& rhs)
	{
	    _data += rhs._data;
	    return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator-(Quaternion<T> const& rhs) const
    {
    	return Quaternion<T>(_data - rhs._data);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator-=(Quaternion<T> const& rhs)
	{
    	_data -= rhs._data;
    	return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator*(Quaternion<T> const& rhs) const
    {
    	return (Quaternion<T>(*this) *= rhs);
    }
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator*(T const& rhs) const
    {
    	return Quaternion<T>(_data * rhs);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator*=(Quaternion<T> const& rhs)
	{
    	auto temp = _data;
    	_data[0] = temp[3] * rhs._data[3] - temp[0] * rhs._data[0] - temp[1] * rhs._data[1] - temp[2] * rhs._data[2];
    	_data[1] = temp[3] * rhs._data[0] + temp[0] * rhs._data[3] + temp[1] * rhs._data[2] - temp[2] * rhs._data[1];
    	_data[2] = temp[3] * rhs._data[1] + temp[1] * rhs._data[3] + temp[2] * rhs._data[0] - temp[0] * rhs._data[2];
    	_data[3] = temp[3] * rhs._data[2] + temp[2] * rhs._data[3] + temp[0] * rhs._data[1] - temp[1] * rhs._data[0];
    	return *this;
	}
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator*=(T const& rhs)
	{
	    _data *= rhs;
	    return *this;
	}
    
    template <typename T> const Quaternion<T> Quaternion<T>::operator/(T const& rhs) const
    {
    	return (Quaternion<T>(*this)/=rhs);
    }
    
    template <typename T> Quaternion<T>& Quaternion<T>::operator/=(T const& rhs)
	{
	    _data /= rhs;
	    return *this;
	}
    
    template <typename T> Quaternion<T> Quaternion<T>::operator-() const
    {
    	return Quaternion<T>(-_data);
    }
    
    template <typename T> bool Quaternion<T>::operator==(Quaternion<T> const& rhs) const
	{
	    return _data == rhs._data;
	}
    
    template <typename T> bool Quaternion<T>::operator!=(Quaternion<T> const& rhs) const
	{
	    return !((*this)==rhs);
	}
    
    template <typename T> T& Quaternion<T>::operator[](std::size_t const& index)
    {
    	return _data[index];
    }
    
    template <typename T> const T& Quaternion<T>::operator[](std::size_t const& index) const
    {
    	return _data[index];
    }
}