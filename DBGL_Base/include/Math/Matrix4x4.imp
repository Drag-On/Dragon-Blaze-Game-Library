//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
	template<typename T> Matrix4x4<T>::Matrix4x4()
	{
		_columns[0] = Vector4<T>(1,0,0,0);
		_columns[1] = Vector4<T>(0,1,0,0);
		_columns[2] = Vector4<T>(0,0,1,0);
		_columns[3] = Vector4<T>(0,0,0,1);
	}
	
	template<typename T> Matrix4x4<T>::Matrix4x4(const Matrix4x4<T> &other)
	{
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
				_columns[x][y] = other[x][y];
	}

	template<typename T> Matrix4x4<T>::~Matrix4x4()
	{
	}
	
	template<typename T> int Matrix4x4<T>::getWidth() const
	{
		return 4;
	}
	
	template<typename T> int Matrix4x4<T>::getHeight() const
	{
		return 4;
	}
	
	template<typename T> void Matrix4x4<T>::transpose()
	{
		Matrix4x4<T> copy(*this); // Need old values
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
				(*this)[x][y] = copy[y][x];
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::getTransposed() const
	{
		Matrix4x4<T> copy(*this);
		copy.transpose();
		return copy;
	}
	
	template<typename T> void Matrix4x4<T>::invert()
	{
		Matrix4x4<T> copy(*this);
		T determinant = copy[0][0] * copy[1][1] * copy[2][2] * copy[3][3] +
						copy[0][0] * copy[2][1] * copy[3][2] * copy[1][3] +
						copy[0][0] * copy[3][2] * copy[1][2] * copy[2][3] +
						
						copy[1][0] * copy[0][1] * copy[3][2] * copy[2][3] +
						copy[1][0] * copy[2][1] * copy[0][2] * copy[3][3] +
						copy[1][0] * copy[3][1] * copy[2][2] * copy[0][3] +
						
						copy[2][0] * copy[0][1] * copy[1][2] * copy[3][3] +
						copy[2][0] * copy[1][1] * copy[3][2] * copy[0][3] +
						copy[2][0] * copy[3][1] * copy[0][2] * copy[1][3] +
						
						copy[3][0] * copy[0][1] * copy[2][2] * copy[1][3] +
						copy[3][0] * copy[1][1] * copy[0][2] * copy[2][3] +
						copy[3][0] * copy[2][1] * copy[1][2] * copy[0][3] -
						
						copy[0][0] * copy[1][1] * copy[3][2] * copy[2][3] -
						copy[0][0] * copy[2][1] * copy[1][2] * copy[3][3] -
						copy[0][0] * copy[3][1] * copy[2][2] * copy[1][3] -
						
						copy[1][0] * copy[0][1] * copy[2][2] * copy[3][3] -
						copy[1][0] * copy[2][1] * copy[3][2] * copy[0][3] -
						copy[1][0] * copy[3][1] * copy[0][2] * copy[2][3] -
						
						copy[2][0] * copy[0][1] * copy[3][2] * copy[1][3] -
						copy[2][0] * copy[1][1] * copy[0][2] * copy[3][3] -
						copy[2][0] * copy[3][1] * copy[1][2] * copy[0][3] -
						
						copy[3][0] * copy[0][1] * copy[1][2] * copy[2][3] -
						copy[3][0] * copy[1][1] * copy[2][2] * copy[0][3] -
						copy[3][0] * copy[2][1] * copy[0][2] * copy[1][3];
		assert(determinant != 0);
		(*this)[0][0] = copy[1][1] * copy[2][2] * copy[3][3] +
						copy[2][1] * copy[3][2] * copy[1][3] +
						copy[3][1] * copy[1][2] * copy[2][3] -
						copy[1][1] * copy[3][2] * copy[2][3] -
						copy[2][1] * copy[1][2] * copy[3][3] -
						copy[3][1] * copy[2][2] * copy[1][3];
		(*this)[1][0] = copy[1][0] * copy[3][2] * copy[2][3] +
						copy[2][0] * copy[1][2] * copy[3][3] +
						copy[3][0] * copy[2][2] * copy[1][3] -
						copy[1][0] * copy[2][2] * copy[3][3] -
						copy[2][0] * copy[3][2] * copy[1][3] -
						copy[3][0] * copy[1][2] * copy[2][3];
		(*this)[2][0] = copy[1][0] * copy[2][1] * copy[3][3] +
						copy[2][0] * copy[3][1] * copy[1][3] +
						copy[3][1] * copy[1][1] * copy[2][3] -
						copy[1][0] * copy[3][2] * copy[2][3] -
						copy[2][0] * copy[1][1] * copy[3][3] -
						copy[3][0] * copy[2][1] * copy[1][3];
		(*this)[3][0] = copy[1][0] * copy[3][1] * copy[2][2] +
						copy[2][0] * copy[1][1] * copy[3][2] +
						copy[3][0] * copy[2][1] * copy[1][2] -
						copy[1][0] * copy[2][1] * copy[3][2] -
						copy[2][0] * copy[3][1] * copy[1][2] -
						copy[3][0] * copy[1][1] * copy[2][2];
		(*this)[0][1] = copy[0][1] * copy[3][2] * copy[2][3] +
						copy[2][1] * copy[0][2] * copy[3][3] +
						copy[3][1] * copy[2][2] * copy[0][3] -
						copy[0][1] * copy[2][2] * copy[3][3] -
						copy[2][1] * copy[3][2] * copy[0][3] -
						copy[3][1] * copy[0][2] * copy[2][3];
		(*this)[1][1] = copy[0][0] * copy[2][2] * copy[3][3] +
						copy[2][0] * copy[3][2] * copy[0][3] +
						copy[3][0] * copy[0][2] * copy[2][3] -
						copy[0][0] * copy[3][2] * copy[2][3] -
						copy[2][0] * copy[0][2] * copy[3][3] -
						copy[3][0] * copy[2][2] * copy[0][3];
		(*this)[2][1] = copy[0][0] * copy[3][1] * copy[2][3] +
						copy[2][0] * copy[0][1] * copy[3][3] +
						copy[3][0] * copy[2][1] * copy[0][3] -
						copy[0][0] * copy[2][1] * copy[3][3] -
						copy[2][0] * copy[3][1] * copy[0][3] -
						copy[3][0] * copy[0][1] * copy[2][3];
		(*this)[3][1] = copy[0][0] * copy[2][1] * copy[3][2] +
						copy[2][0] * copy[3][1] * copy[0][2] +
						copy[3][0] * copy[0][1] * copy[2][2] -
						copy[0][0] * copy[3][1] * copy[2][2] -
						copy[2][0] * copy[0][1] * copy[3][2] -
						copy[3][0] * copy[2][1] * copy[0][2];
		(*this)[0][2] = copy[0][1] * copy[1][2] * copy[3][3] +
						copy[1][1] * copy[3][2] * copy[0][3] +
						copy[3][1] * copy[0][2] * copy[1][3] -
						copy[0][1] * copy[3][2] * copy[1][3] -
						copy[1][1] * copy[0][2] * copy[3][3] -
						copy[3][1] * copy[1][2] * copy[0][3];
		(*this)[1][2] = copy[0][0] * copy[3][2] * copy[1][3] +
						copy[1][0] * copy[0][2] * copy[3][3] +
						copy[3][0] * copy[1][2] * copy[0][3] -
						copy[0][0] * copy[1][2] * copy[3][3] -
						copy[1][0] * copy[3][2] * copy[0][3] -
						copy[3][0] * copy[0][2] * copy[1][3];
		(*this)[2][2] = copy[0][0] * copy[1][1] * copy[3][3] +
						copy[1][0] * copy[3][1] * copy[0][3] +
						copy[3][0] * copy[0][1] * copy[1][3] -
						copy[0][0] * copy[3][1] * copy[1][3] -
						copy[1][0] * copy[0][1] * copy[3][3] -
						copy[3][0] * copy[1][1] * copy[0][3];
		(*this)[3][2] = copy[0][0] * copy[3][1] * copy[1][2] +
						copy[1][0] * copy[0][1] * copy[3][2] +
						copy[3][0] * copy[1][1] * copy[0][2] -
						copy[0][0] * copy[1][1] * copy[3][2] -
						copy[1][0] * copy[3][1] * copy[0][2] -
						copy[3][0] * copy[0][1] * copy[1][2];
		(*this)[0][3] = copy[0][1] * copy[2][2] * copy[1][3] +
						copy[1][1] * copy[0][2] * copy[2][3] +
						copy[2][1] * copy[1][2] * copy[0][3] -
						copy[0][1] * copy[1][2] * copy[2][3] -
						copy[1][1] * copy[2][2] * copy[0][3] -
						copy[2][1] * copy[0][2] * copy[1][3];
		(*this)[1][3] = copy[0][0] * copy[1][2] * copy[2][3] +
						copy[1][0] * copy[2][2] * copy[0][3] +
						copy[2][0] * copy[0][2] * copy[1][3] -
						copy[0][0] * copy[2][2] * copy[1][3] -
						copy[1][0] * copy[0][2] * copy[2][3] -
						copy[2][0] * copy[1][2] * copy[0][3];
		(*this)[2][3] = copy[0][0] * copy[2][1] * copy[1][3] +
						copy[1][0] * copy[0][1] * copy[2][3] +
						copy[2][0] * copy[1][1] * copy[0][3] -
						copy[0][0] * copy[1][1] * copy[2][3] -
						copy[1][0] * copy[2][1] * copy[0][3] -
						copy[2][0] * copy[0][1] * copy[1][3];
		(*this)[3][3] = copy[0][0] * copy[1][1] * copy[2][2] +
						copy[1][0] * copy[2][1] * copy[0][2] +
						copy[2][0] * copy[0][1] * copy[1][2] -
						copy[0][0] * copy[2][1] * copy[1][2] -
						copy[1][0] * copy[0][1] * copy[2][2] -
						copy[2][0] * copy[1][1] * copy[0][2];
		(*this) *= 1 / determinant;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::getInverted() const
	{
		Matrix4x4<T> copy(*this);
		copy.invert();
		return copy;
	}
	
	template<typename T> bool Matrix4x4<T>::isZero() const
	{
		for(int i = 0; i < getWidth(); i++)
			if(!(*this)[i].isZero())
				return false;
		return true;
	}
	
	template<typename T> bool Matrix4x4<T>::isIdentity() const
	{
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
			{
				if(x == y && (*this)[x][y] != 1)
					return false;
				if(x != y && (*this)[x][y] != 0)
					return false;
			}
		return true;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeTranslation(T x, T y, T z)
	{
		Matrix4x4<T> mat;
		mat[3][0] = x;
		mat[3][1] = y;
		mat[3][2] = z;
		return mat;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeRotationX(T angle)
	{
		Matrix4x4<T> mat;
		T cosAngle = cos(angle);
		T sinAngle = sin(angle);
		mat[1][1] = cosAngle;
		mat[2][1] = -sinAngle;
		mat[1][2] = sinAngle;
		mat[2][2] = cosAngle;
		return mat;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeRotationY(T angle)
	{
		Matrix4x4<T> mat;
		T cosAngle = cos(angle);
		T sinAngle = sin(angle);
		mat[0][0] = cosAngle;
		mat[2][0] = sinAngle;
		mat[0][2] = -sinAngle;
		mat[2][2] = cosAngle;
		return mat;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeRotationZ(T angle)
	{
		Matrix4x4<T> mat;
		T cosAngle = cos(angle);
		T sinAngle = sin(angle);
		mat[0][0] = cosAngle;
		mat[1][0] = -sinAngle;
		mat[0][1] = sinAngle;
		mat[1][1] = cosAngle;
		return mat;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeRotation(T xAngle, T yAngle, T zAngle)
	{
	    return makeRotationX(xAngle) * makeRotationY(yAngle) * makeRotationZ(zAngle);
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeRotation(Vector4<T> vec, T angle)
	{
		vec.normalize();
		Matrix4x4<T> mat;
		T cosAngle = cos(angle);
		T sinAngle = sin(angle);
		mat[0][0] = vec[0] * vec[0] * (1 - cosAngle) + cosAngle;
		mat[1][0] = vec[0] * vec[1] * (1 - cosAngle) - vec[2] * sinAngle;
		mat[2][0] = vec[0] * vec[2] * (1 - cosAngle) + vec[1] * sinAngle;
		mat[0][1] = vec[1] * vec[0] * (1 - cosAngle) + vec[2] * sinAngle;
		mat[1][1] = vec[1] * vec[1] * (1 - cosAngle) + cosAngle;
		mat[2][1] = vec[1] * vec[2] * (1 - cosAngle) - vec[0] * sinAngle;
		mat[0][2] = vec[2] * vec[0] * (1 - cosAngle) - vec[1] * sinAngle;
		mat[1][2] = vec[2] * vec[1] * (1 - cosAngle) + vec[0] * sinAngle;
		mat[2][2] = vec[2] * vec[2] * (1 - cosAngle) + cosAngle;
		return mat;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeScale(T factor)
	{
		Matrix4x4<T> mat;
		mat *= factor;
		return mat;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeScale(T x, T y, T z, T w)
	{
		Matrix4x4<T> mat;
		mat[0][0] *= x;
		mat[1][1] *= y;
		mat[2][2] *= z;
		mat[3][3] *= w;
		return mat;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeView(Vector3<T> const& pos, Vector3<T> const& target, Vector3<T> const& up)
	{
		auto zAxis = pos - target;
		zAxis.normalize();
		auto xAxis = up;
		xAxis *= zAxis;
		xAxis.normalize();
		auto yAxis = zAxis;
		yAxis *= xAxis;
		Matrix4x4<T> mat;
		mat.view(pos, target, up);
		return mat;
	}
	
	template<typename T> void Matrix4x4<T>::view(Vector3<T> const& pos, Vector3<T> const& target, Vector3<T> const& up)
	{
		auto zAxis = pos - target;
		zAxis.normalize();
		auto xAxis = up;
		xAxis *= zAxis;
		xAxis.normalize();
		auto yAxis = zAxis;
		yAxis *= xAxis;
		(*this)[0][0] = xAxis.getX();
		(*this)[1][0] = yAxis.getX();
		(*this)[2][0] = zAxis.getX();
		(*this)[3][0] = -(xAxis * pos);
		(*this)[0][1] = xAxis.getY();
		(*this)[1][1] = yAxis.getY();
		(*this)[2][1] = zAxis.getY();
		(*this)[3][1] = -(yAxis * pos);
		(*this)[0][2] = xAxis.getZ();
		(*this)[1][2] = yAxis.getZ();
		(*this)[2][2] = zAxis.getZ();
		(*this)[3][2] = -(zAxis * pos);
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::makeProjection(T fieldOfView, T aspectRatio, T near, T far)
	{
		T h = std::tan(pi_2() - fieldOfView / 2);
		T w = h / aspectRatio;
		Matrix4x4<T> mat;
		mat.projection(fieldOfView, aspectRatio, near, far);
		return mat;
	}
	
	template<typename T> void Matrix4x4<T>::projection(T fieldOfView, T aspectRatio, T near, T far)
	{
		T h = std::tan(pi_2() - fieldOfView / 2);
		T w = h / aspectRatio;
		(*this)[0][0] = w;
		(*this)[1][1] = h;
		(*this)[2][2] = far/(near - far);
		(*this)[3][2] = (near * far)/(near - far);
		(*this)[2][3] = -1;
		(*this)[3][3] = 0;
	}
	
	template<typename T> Matrix4x4<T>& Matrix4x4<T>::operator=(Matrix4x4<T> const& rhs) 
	{ 
		if (*this != rhs)
		{ 
			for(int i = 0; i < getWidth(); i++)
				(*this)[i] = rhs[i];
		} 
		return *this;
	}
	
	template<typename T> const Matrix4x4<T> Matrix4x4<T>::operator+(Matrix4x4<T> const& rhs) const
	{ 
		Matrix4x4<T> tmp(*this);
		tmp += rhs;
		return tmp;
	}
	
	template<typename T> Matrix4x4<T>& Matrix4x4<T>::operator+=(Matrix4x4<T> const& rhs)
	{
		for(int i = 0; i < getWidth(); i++)
			(*this)[i] += rhs[i];
		return *this;
	}
	
	template<typename T> const Matrix4x4<T> Matrix4x4<T>::operator-(Matrix4x4<T> const& rhs) const
	{ 
		Matrix4x4<T> tmp(*this);
		tmp -= rhs;
		return tmp;
	}
		
	template<typename T> Matrix4x4<T>& Matrix4x4<T>::operator-=(Matrix4x4<T> const& rhs)
	{
		for(int i = 0; i < getWidth(); i++)
			(*this)[i] -= rhs[i];
		return *this;
	}
	
	template<typename T> const Matrix4x4<T> Matrix4x4<T>::operator*(Matrix4x4<T> const& rhs) const
	{
		Matrix4x4<T> copy(*this);
		copy *= rhs;
		return copy;
	}
	
	template<typename T> const Vector4<T> Matrix4x4<T>::operator*(Vector4<T> const& rhs) const
	{
		Vector4<T> vec;
		for(int y = 0; y < getHeight(); y++)
			for(int x = 0; x < getWidth(); x++)
				vec[y] += (*this)[x][y] * rhs[x];
		return vec;
	}
	
	template<typename T> const Matrix4x4<T> Matrix4x4<T>::operator*(T const& rhs) const
	{ 
		Matrix4x4<T> tmp(*this);
		tmp *= rhs;
		return tmp;
	}
	
	template<typename T> Matrix4x4<T>& Matrix4x4<T>::operator*=(Matrix4x4<T> const& rhs) 
	{
		Matrix4x4<T> copy(*this);
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
			{
				(*this)[x][y] = 0;
				for(int i = 0; i < getHeight(); i++)
					(*this)[x][y] += copy[i][y] * rhs[x][i];
			}
		return *this;
	}
		
	template<typename T> Matrix4x4<T>& Matrix4x4<T>::operator*=(T const& rhs)
	{
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
				(*this)[x][y] *= rhs;
		return *this;
	}
	
	template<typename T> const Matrix4x4<T> Matrix4x4<T>::operator/(T const& rhs) const
	{ 
		Matrix4x4<T> tmp(*this);
		tmp /= rhs;
		return tmp;
	}
		
	template<typename T> Matrix4x4<T>& Matrix4x4<T>::operator/=(T const& rhs)
	{
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
				(*this)[x][y] /= rhs;
		return *this;
	}
	
	template<typename T> Matrix4x4<T> Matrix4x4<T>::operator-() const
	{
		Matrix4x4<T> tmp(*this);
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
				tmp[x][y] = -(*this)[x][y];
		return tmp;
	}
	
	template<typename T> bool Matrix4x4<T>::operator==(Matrix4x4<T> const& rhs) const
	{
		for(int x = 0; x < getWidth(); x++)
			for(int y = 0; y < getHeight(); y++)
				if((*this)[x][y] != rhs[x][y])
					return false;
		return true;
	}
	
	template<typename T> bool Matrix4x4<T>::operator!=(Matrix4x4<T> const& rhs) const
	{
		return !(*this == rhs);
	}

	template<typename T> Vector4<T>& Matrix4x4<T>::operator[](std::size_t const& index)
	{
		if(index < getWidth())
			return _columns[index];
		else
		{
			LOG->error("Tried to access column %d of %d-width matrix!", index, getWidth());
			exit(EXIT_FAILURE);
		}
	}
	
	template<typename T> const Vector4<T>& Matrix4x4<T>::operator[](std::size_t const& index) const
	{
		if(index < getWidth())
			return _columns[index];
		else
		{
			LOG->error("Tried to access column %d of %d-width matrix!", index, getWidth());
			exit(EXIT_FAILURE);
		}
	}
}
