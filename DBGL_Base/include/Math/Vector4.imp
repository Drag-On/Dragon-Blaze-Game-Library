//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
	template<typename T> Vector4<T>::Vector4() : m_x(0), m_y(0), m_z(0), m_w(0)
	{
	}
	
	template<typename T> Vector4<T>::Vector4(T x, T y, T z, T w) : m_x(x), m_y(y), m_z(z), m_w(w)
	{
	}
	
	template<typename T> Vector4<T>::Vector4(const Vector4<T> &other) :m_x(other[0]), m_y(other[1]), m_z(other[2]), m_w(other[3])
	{
	}

	template<typename T> Vector4<T>::~Vector4()
	{
	}
	
	template<typename T> std::size_t Vector4<T>::getDimension() const
	{
		return 4;
	}
	
	template<typename T> const T& Vector4<T>::x() const
	{
		return m_x;
	}
	
	template<typename T> T& Vector4<T>::x()
	{
		return m_x;
	}
	
	template<typename T> const T& Vector4<T>::y() const
	{
		return m_y;
	}
	
	template<typename T> T& Vector4<T>::y()
	{
		return m_y;
	}
	
	template<typename T> const T& Vector4<T>::z() const
	{
		return m_z;
	}
	
	template<typename T> T& Vector4<T>::z()
	{
		return m_z;
	}
	
	template<typename T> const T& Vector4<T>::w() const
	{
		return m_w;
	}
	
	template<typename T> T& Vector4<T>::w()
	{
		return m_w;
	}
	
	template<typename T> T Vector4<T>::getSquaredLength() const
	{
		T sqlen = 0;
		for(int i = 0; i < getDimension(); i++)
			sqlen += (*this)[i] * (*this)[i];
		return sqlen;
	}
	
	template<typename T> T Vector4<T>::getLength() const
	{
		return static_cast<T>(std::sqrt(static_cast<double>(getSquaredLength())));
	}
	
	template<typename T> Vector4<T>& Vector4<T>::normalize()
	{
		T length = getLength();
		for(int i = 0; i < getDimension(); i++)
			(*this)[i] /= length;
		return *this;
	}
	
	template<typename T> Vector4<T> Vector4<T>::getNormalized() const
	{
		Vector4<T> copy(*this);
		copy.normalize();
		return copy;
	}
	
	template<typename T> Vector4<T> Vector4<T>::dot(Vector4<T> const& rhs) const
	{
		return (*this) * rhs;
	}
	
	template<typename T> Vector4<T> Vector4<T>::cross(Vector4<T> const& rhs) const
	{
		Vector4<T> copy(*this);
		copy *= rhs;
		return copy;
	}
	
	template<typename T> bool Vector4<T>::isZero() const
	{
		for(int i = 0; i < getDimension(); i++)
			if((*this)[i] != 0)
				return false;
		return true;
	}
	
	template<typename T> bool Vector4<T>::isSimilar(Vector4<T> const& other, double precision) const
	{
		for(int i = 0; i < getDimension(); i++)
			if(!dbgl::isSimilar((*this)[i], other[i], precision))
				return false;
		return true;
	}
	
	template<typename T> Vector4<T>& Vector4<T>::translate(T x, T y, T z, T w)
	{
		m_x += x;
		m_y += y;
		m_z += z;
		m_w += w;
		return *this;
	}
	
	template<typename T> const T* Vector4<T>::getDataPointer() const
	{
		return &((*this)[0]);
	}
	
	template<typename T> Vector4<T>& Vector4<T>::operator=(Vector4<T> const& rhs) 
	{ 
		if (*this != rhs)
		{ 
			for(int i = 0; i < getDimension(); i++)
				(*this)[i] = rhs[i];
		} 
		return *this;
	}
	
	template<typename T> const Vector4<T> Vector4<T>::operator+(Vector4<T> const& rhs) const
	{ 
		Vector4<T> tmp(*this);
		tmp += rhs;
		return tmp;
	}
	
	template<typename T> Vector4<T>& Vector4<T>::operator+=(Vector4<T> const& rhs)
	{
		for(int i = 0; i < getDimension(); i++)
			(*this)[i] += rhs[i];
		return *this;
	}
	
	template<typename T> const Vector4<T> Vector4<T>::operator-(Vector4<T> const& rhs) const
	{ 
		Vector4<T> tmp(*this);
		tmp -= rhs;
		return tmp;
	}
		
	template<typename T> Vector4<T>& Vector4<T>::operator-=(Vector4<T> const& rhs)
	{
		for(int i = 0; i < getDimension(); i++)
			(*this)[i] -= rhs[i];
		return *this;
	}
	
	template<typename T> const T Vector4<T>::operator*(Vector4<T> const& rhs) const
	{
		T dotProd = 0;
		for(int i = 0; i < getDimension(); i++)
			dotProd += (*this)[i] * rhs[i];
		return dotProd;
	}
	
	template<typename T> const Vector4<T> Vector4<T>::operator*(T const& rhs) const
	{ 
		Vector4<T> tmp(*this);
		tmp *= rhs;
		return tmp;
	}
		
	template<typename T> Vector4<T>& Vector4<T>::operator*=(T const& rhs)
	{
		for(int i = 0; i < getDimension(); i++)
			(*this)[i] *= rhs;
		return *this;
	}
	
	template<typename T> Vector4<T>& Vector4<T>::operator*=(Vector4<T> const& rhs)
	{
		auto temp(*this); // Need copy of unmodified data
		for(int i = 0; i < getDimension(); i++)
		{
			int i1 = (i+1) % getDimension();
			int i2 = (i+2) % getDimension();
			(*this)[i] = temp[i1]*rhs[i2] - temp[i2]*rhs[i1];
		}
		return *this;
	}
	
	template<typename T> const Vector4<T> Vector4<T>::operator/(T const& rhs) const
	{ 
		Vector4<T> tmp(*this);
		tmp /= rhs;
		return tmp;
	}
		
	template<typename T> Vector4<T>& Vector4<T>::operator/=(T const& rhs)
	{
		for(int i = 0; i < getDimension(); i++)
			(*this)[i] /= rhs;
		return *this;
	}
	
	template<typename T> Vector4<T> Vector4<T>::operator-() const
	{
		Vector4<T> tmp(*this);
		for(int i = 0; i < getDimension(); i++)
			tmp[i] = -(*this)[i];
		return tmp;
	}
	
	template<typename T> bool Vector4<T>::operator==(Vector4<T> const& rhs) const
	{
		for(int i = 0; i < getDimension(); i++)
			if((*this)[i] != rhs[i])
				return false;
		return true;
	}
	
	template<typename T> bool Vector4<T>::operator!=(Vector4<T> const& rhs) const
	{
		return !(*this == rhs);
	}
	
	template<typename T> bool Vector4<T>::operator<(Vector4<T> const& rhs) const
	{
		return this->getLength() < rhs.getLength();
	}
	
	template<typename T> bool Vector4<T>::operator>(Vector4<T> const& rhs) const
	{
		return this->getLength() > rhs.getLength();
	}
	
	template<typename T> bool Vector4<T>::operator<=(Vector4<T> const& rhs) const
	{
		return this->getLength() <= rhs.getLength();
	}
	
	template<typename T> bool Vector4<T>::operator>=(Vector4<T> const& rhs) const
	{
		return this->getLength() >= rhs.getLength();
	}

	template<typename T> T& Vector4<T>::operator[](std::size_t const& index)
	{
		if(index < getDimension())
			return (&m_x)[index];
		else
		{
			LOG->error("Tried to access element %d of %d-length vector!", index, getDimension());
			exit(EXIT_FAILURE);
		}
	}
	
	template<typename T> const T& Vector4<T>::operator[](std::size_t const& index) const
	{
		if(index < getDimension())
			return (&m_x)[index];
		else
		{
			LOG->error("Tried to access element %d of %d-length vector!", index, getDimension());
			exit(EXIT_FAILURE);
		}
	}
}
