//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// This is the common implementation part of all Vector<T, N>
// specializations.
//
// Needed #defines:
//	T: Undefined for the general version
//	T: type, eg. "float" for a specialized version
//	TEMPLATE_LIST: "typename T, unsigned int N" for the general version
//	TEMPLATE_LIST: "unsigned int N" for a specialized version
//	RETURN_QUALIFIER: "const" if T is a pointer type
// 	RETURN_QUALIFIER: Empty otherwise
//////////////////////////////////////////////////////////////////////

template<TEMPLATE_LIST> Vector<T,N>::Vector()
{
	for(int i = 0; i < getDimension(); i++)
		(*this)[i] = 0;
}

template<TEMPLATE_LIST> Vector<T,N>::Vector(const Vector<T,N> &other)
{
	assert(this->getDimension() == other.getDimension());
	for(int i = 0; i < getDimension(); i++)
		(*this)[i] = other[i];
}

template<TEMPLATE_LIST> Vector<T,N>::Vector(std::initializer_list<T> args)
{
	unsigned int i = 0;
    for(auto n : args)
    {
    	if(i >= getDimension())
    		throw(std::invalid_argument{"Too many arguments."});
    	(*this)[i] = n;
    	i++;
    }
}

template<TEMPLATE_LIST> Vector<T,N>::~Vector()
{
}

template<TEMPLATE_LIST> constexpr std::size_t Vector<T,N>::getDimension()
{
	return N;
}

template<TEMPLATE_LIST> T Vector<T,N>::getSquaredLength() const
{
	T sqlen = 0;
	for(int i = 0; i < getDimension(); i++)
		sqlen += (*this)[i] * (*this)[i];
	return sqlen;
}

template<TEMPLATE_LIST> T Vector<T,N>::getLength() const
{
	return static_cast<T>(std::sqrt(static_cast<double>(getSquaredLength())));
}

template<TEMPLATE_LIST> Vector<T,N>& Vector<T,N>::normalize()
{
	T length = getLength();
	for(int i = 0; i < getDimension(); i++)
		(*this)[i] /= length;
	return *this;
}

template<TEMPLATE_LIST> Vector<T,N> Vector<T,N>::getNormalized() const
{
	Vector<T,N> copy(*this);
	copy.normalize();
	return copy;
}

template<TEMPLATE_LIST> T Vector<T,N>::dot(Vector<T,N> const& rhs) const
{
	return (*this) * rhs;
}

template<TEMPLATE_LIST> Vector<T,N> Vector<T,N>::cross(Vector<T,N> const& rhs) const
{
	Vector<T,N> copy(*this);
	copy *= rhs;
	return copy;
}

template<TEMPLATE_LIST> bool Vector<T,N>::isZero() const
{
	for(int i = 0; i < getDimension(); i++)
		if((*this)[i] != 0)
			return false;
	return true;
}

template<TEMPLATE_LIST> bool Vector<T, N>::isSimilar(Vector<T, N> const& other, double precision) const
{
	return ((*this) - other).getSquaredLength() <= precision * precision;
}

template<TEMPLATE_LIST> const T* Vector<T,N>::getDataPointer() const
{
	return &((*this)[0]);
}

template<TEMPLATE_LIST> Vector<T,N>& Vector<T,N>::operator=(Vector<T,N> const& rhs) 
{ 
	if (*this != rhs)
	{ 
		for(int i = 0; i < getDimension(); i++)
			(*this)[i] = rhs[i];
	} 
	return *this;
}

template<TEMPLATE_LIST> RETURN_QUALIFIER Vector<T,N> Vector<T,N>::operator+(Vector<T,N> const& rhs) const
{ 
	auto tmp(*this);
	tmp += rhs;
	return tmp;
}

template<TEMPLATE_LIST> Vector<T,N>& Vector<T,N>::operator+=(Vector<T,N> const& rhs)
{
	for(int i = 0; i < getDimension(); i++)
		(*this)[i] += rhs[i];
	return *this;
}

template<TEMPLATE_LIST> RETURN_QUALIFIER Vector<T,N> Vector<T,N>::operator-(Vector<T,N> const& rhs) const
{ 
	auto tmp(*this);
	tmp -= rhs;
	return tmp;
}
	
template<TEMPLATE_LIST> Vector<T,N>& Vector<T,N>::operator-=(Vector<T,N> const& rhs)
{
	for(int i = 0; i < getDimension(); i++)
		(*this)[i] -= rhs[i];
	return *this;
}

template<TEMPLATE_LIST> RETURN_QUALIFIER T Vector<T,N>::operator*(Vector<T,N> const& rhs) const
{
	T dotProd = 0;
	for(int i = 0; i < getDimension(); i++)
		dotProd += (*this)[i] * rhs[i];
	return dotProd;
}

template<TEMPLATE_LIST> RETURN_QUALIFIER Vector<T,N> Vector<T,N>::operator*(T const& rhs) const
{ 
	auto tmp(*this);
	tmp *= rhs;
	return tmp;
}
	
template<TEMPLATE_LIST> Vector<T,N>& Vector<T,N>::operator*=(T const& rhs)
{
	for(int i = 0; i < getDimension(); i++)
		(*this)[i] *= rhs;
	return *this;
}

template<TEMPLATE_LIST> Vector<T,N>& Vector<T,N>::operator*=(Vector<T,N> const& rhs)
{
	auto temp(*this); // Need copy of unmodified data
	for(int i = 0; i < getDimension(); i++)
	{
		int i1 = (i+1) % getDimension();
		int i2 = (i+2) % getDimension();
		(*this)[i] = temp[i1]*rhs[i2] - temp[i2]*rhs[i1];
	}
	return *this;
}

template<TEMPLATE_LIST> RETURN_QUALIFIER Vector<T,N> Vector<T,N>::operator/(T const& rhs) const
{ 
	auto tmp(*this);
	tmp /= rhs;
	return tmp;
}
	
template<TEMPLATE_LIST> Vector<T,N>& Vector<T,N>::operator/=(T const& rhs)
{
	for(int i = 0; i < getDimension(); i++)
		(*this)[i] /= rhs;
	return *this;
}

template<TEMPLATE_LIST> Vector<T,N> Vector<T,N>::operator-() const
{
	auto tmp(*this);
	for(int i = 0; i < getDimension(); i++)
		tmp[i] = -(*this)[i];
	return tmp;
}

template<TEMPLATE_LIST> bool Vector<T,N>::operator==(Vector<T,N> const& rhs) const
{
	for(int i = 0; i < getDimension(); i++)
		if((*this)[i] != rhs[i])
			return false;
	return true;
}

template<TEMPLATE_LIST> bool Vector<T,N>::operator!=(Vector<T,N> const& rhs) const
{
	return !(*this == rhs);
}

template<TEMPLATE_LIST> bool Vector<T,N>::operator<(Vector<T,N> const& rhs) const
{
	return this->getLength() < rhs.getLength();
}

template<TEMPLATE_LIST> bool Vector<T,N>::operator>(Vector<T,N> const& rhs) const
{
	return this->getLength() > rhs.getLength();
}

template<TEMPLATE_LIST> bool Vector<T,N>::operator<=(Vector<T,N> const& rhs) const
{
	return this->getLength() <= rhs.getLength();
}

template<TEMPLATE_LIST> bool Vector<T,N>::operator>=(Vector<T,N> const& rhs) const
{
	return this->getLength() >= rhs.getLength();
}

template<TEMPLATE_LIST> T& Vector<T,N>::operator[](std::size_t const& index)
{
	if(index < getDimension())
		return m_elements[index];
	else
	{
		LOG.error("Tried to access element %d of %d-length vector!", index, getDimension());
		exit(EXIT_FAILURE);
	}
}

template<TEMPLATE_LIST> const T& Vector<T,N>::operator[](std::size_t const& index) const
{
	if(index < getDimension())
		return m_elements[index];
	else
	{
		LOG.error("Tried to access element %d of %d-length vector!", index, getDimension());
		exit(EXIT_FAILURE);
	}
}