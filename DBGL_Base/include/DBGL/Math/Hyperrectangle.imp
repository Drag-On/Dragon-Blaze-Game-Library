//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template<typename T, unsigned int D> Hyperrectangle<T, D>::Hyperrectangle()
    {
	for (unsigned int i = 0; i < D; i++)
	{
	    m_pos[i] = 0;
	    m_extent[i] = 1;
	}
    }

    template<typename T, unsigned int D> Hyperrectangle<T, D>::Hyperrectangle(Vector<T, D> const& pos,
	    Vector<T, D> const& extent)
    {
	m_pos = pos;
	m_extent = extent;
    }

    template<typename T, unsigned int D> Hyperrectangle<T, D>::Hyperrectangle(
	    Hyperrectangle<T, D> const& other)
    {
	m_pos = other.m_pos;
	m_extent = other.m_extent;
    }

    template<typename T, unsigned int D> Vector<T, D> const& Hyperrectangle<T, D>::getPos() const
    {
	return m_pos;
    }

    template<typename T, unsigned int D> Vector<T, D>& Hyperrectangle<T, D>::pos()
    {
	return m_pos;
    }

    template<typename T, unsigned int D> Vector<T, D> const& Hyperrectangle<T, D>::getExtent() const
    {
	return m_extent;
    }

    template<typename T, unsigned int D> Vector<T, D>& Hyperrectangle<T, D>::extent()
    {
	return m_extent;
    }

    template<typename T, unsigned int D> bool Hyperrectangle<T, D>::isIn(Vector<T, D> const& point) const
    {
	for(unsigned int i = 0; i < D; i++)
	{
	    if(point[i] < m_pos[i] || point[i] > m_pos[i] + m_extent[i])
		return false;
	}
	return true;
    }

    template<typename T, unsigned int D> bool Hyperrectangle<T, D>::overlaps(Hyperrectangle<T, D> const& other) const
    {
	for(unsigned int i = 0; i < D; i++)
	{
	    if(other.m_pos[i] + other.m_extent[i] < m_pos[i] || other.m_pos[i] > m_pos[i] + m_extent[i])
		return false;
	}
	return true;
    }

    template<typename T, unsigned int D> Hyperrectangle<T, D>& Hyperrectangle<T, D>::operator=(
	    Hyperrectangle<T, D> const& rhs)
    {
	m_pos = rhs.m_pos;
	m_extent = rhs.m_extent;
	return *this;
    }

    template<typename T, unsigned int D> bool Hyperrectangle<T, D>::operator==(
	    Hyperrectangle<T, D> const& rhs) const
    {
	return (m_pos == rhs.m_pos && m_extent == rhs.m_extent);
    }

    template<typename T, unsigned int D> bool Hyperrectangle<T, D>::operator!=(
	    Hyperrectangle<T, D> const& rhs) const
    {
	return !(*this == rhs);
    }

    template<typename T, unsigned int D> unsigned int Hyperrectangle<T, D>::getDimension()
    {
	return D;
    }

    /*
     * Rectangle
     */

    template<typename T> Hyperrectangle<T, 2>::Hyperrectangle()
    {
	for (unsigned int i = 0; i < 2; i++)
	{
	    m_pos[i] = 0;
	    m_extent[i] = 1;
	}
    }

    template<typename T> Hyperrectangle<T, 2>::Hyperrectangle(Vector<T, 2> const& pos,
	    Vector<T, 2> const& extent)
    {
	m_pos = pos;
	m_extent = extent;
    }

    template<typename T> Hyperrectangle<T, 2>::Hyperrectangle(Hyperrectangle<T, 2> const& other)
    {
	m_pos = other.m_pos;
	m_extent = other.m_extent;
    }

    template<typename T> Vector2<T> const& Hyperrectangle<T, 2>::getPos() const
    {
	return m_pos;
    }

    template<typename T> Vector2<T>& Hyperrectangle<T, 2>::pos()
    {
	return m_pos;
    }

    template<typename T> Vector2<T> const& Hyperrectangle<T, 2>::getExtent() const
    {
	return m_extent;
    }

    template<typename T> Vector2<T>& Hyperrectangle<T, 2>::extent()
    {
	return m_extent;
    }

    template<typename T> bool Hyperrectangle<T, 2>::isIn(Vector<T, 2> const& point) const
    {
	for(unsigned int i = 0; i < 2; i++)
	{
	    if(point[i] < m_pos[i] || point[i] > m_pos[i] + m_extent[i])
		return false;
	}
	return true;
    }

    template<typename T> bool Hyperrectangle<T, 2>::overlaps(Hyperrectangle<T, 2> const& other) const
    {
	for(unsigned int i = 0; i < 2; i++)
	{
	    if(other.m_pos[i] + other.m_extent[i] < m_pos[i] || other.m_pos[i] > m_pos[i] + m_extent[i])
		return false;
	}
	return true;
    }

    template<typename T> Hyperrectangle<T, 2>& Hyperrectangle<T, 2>::operator=(
	    Hyperrectangle<T, 2> const& rhs)
    {
	m_pos = rhs.m_pos;
	m_extent = rhs.m_extent;
	return *this;
    }

    template<typename T> bool Hyperrectangle<T, 2>::operator==(Hyperrectangle<T, 2> const& rhs) const
    {
	return (m_pos == rhs.m_pos && m_extent == rhs.m_extent);
    }

    template<typename T> bool Hyperrectangle<T, 2>::operator!=(Hyperrectangle<T, 2> const& rhs) const
    {
	return !(*this == rhs);
    }

    template<typename T> unsigned int Hyperrectangle<T, 2>::getDimension()
    {
	return 2;
    }

    /*
     * Box
     */

    template<typename T> Hyperrectangle<T, 3>::Hyperrectangle()
    {
	for (unsigned int i = 0; i < 2; i++)
	{
	    m_pos[i] = 0;
	    m_extent[i] = 1;
	}
    }

    template<typename T> Hyperrectangle<T, 3>::Hyperrectangle(Vector<T, 3> const& pos,
	    Vector<T, 3> const& extent)
    {
	m_pos = pos;
	m_extent = extent;
    }

    template<typename T> Hyperrectangle<T, 3>::Hyperrectangle(Hyperrectangle<T, 3> const& other)
    {
	m_pos = other.m_pos;
	m_extent = other.m_extent;
    }

    template<typename T> Vector3<T> const& Hyperrectangle<T, 3>::getPos() const
    {
	return m_pos;
    }

    template<typename T> Vector3<T>& Hyperrectangle<T, 3>::pos()
    {
	return m_pos;
    }

    template<typename T> Vector3<T> const& Hyperrectangle<T, 3>::getExtent() const
    {
	return m_extent;
    }

    template<typename T> Vector3<T>& Hyperrectangle<T, 3>::extent()
    {
	return m_extent;
    }

    template<typename T> bool Hyperrectangle<T, 3>::isIn(Vector<T, 3> const& point) const
    {
	for(unsigned int i = 0; i < 3; i++)
	{
	    if(point[i] < m_pos[i] || point[i] > m_pos[i] + m_extent[i])
		return false;
	}
	return true;
    }

    template<typename T> bool Hyperrectangle<T, 3>::overlaps(Hyperrectangle<T, 3> const& other) const
    {
	for(unsigned int i = 0; i < 3; i++)
	{
	    if(other.m_pos[i] + other.m_extent[i] < m_pos[i] || other.m_pos[i] > m_pos[i] + m_extent[i])
		return false;
	}
	return true;
    }

    template<typename T> Hyperrectangle<T, 3>& Hyperrectangle<T, 3>::operator=(
	    Hyperrectangle<T, 3> const& rhs)
    {
	m_pos = rhs.m_pos;
	m_extent = rhs.m_extent;
	return *this;
    }

    template<typename T> bool Hyperrectangle<T, 3>::operator==(Hyperrectangle<T, 3> const& rhs) const
    {
	return (m_pos == rhs.m_pos && m_extent == rhs.m_extent);
    }

    template<typename T> bool Hyperrectangle<T, 3>::operator!=(Hyperrectangle<T, 3> const& rhs) const
    {
	return !(*this == rhs);
    }

    template<typename T> unsigned int Hyperrectangle<T, 3>::getDimension()
    {
	return 3;
    }
}

