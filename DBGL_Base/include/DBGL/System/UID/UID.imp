//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template<unsigned int GROUP, typename T> T UID<GROUP, T>::next = 0;
    template<unsigned int GROUP, typename T> std::vector<T> UID<GROUP, T>::open{};

    template<unsigned int GROUP, typename T> UID<GROUP, T>::UID()
    {
	m_pId = new T{};
	*m_pId = getNext();
	m_pRefCount = new unsigned long{1};
    }

    template<unsigned int GROUP, typename T> UID<GROUP, T>::UID(T uid)
    {
	m_pId = new T{};
	*m_pId = tryUse(uid);
	m_pRefCount = new unsigned long{1};
    }

    template<unsigned int GROUP, typename T> UID<GROUP, T>::UID(UID<GROUP, T> const& other)
    {
	m_pId = other.m_pId;
	m_pRefCount = other.m_pRefCount;
	*m_pRefCount += 1;
    }

    template<unsigned int GROUP, typename T> UID<GROUP, T>& UID<GROUP, T>::operator=(UID<GROUP, T> const& other)
    {
	m_pId = other.m_pId;
	m_pRefCount = other.m_pRefCount;
	*m_pRefCount += 1;
    }

    template<unsigned int GROUP, typename T> UID<GROUP, T>::~UID()
    {
	*m_pRefCount -= 1;
	if (*m_pRefCount <= 0)
	{
	    invalidate();
	    delete m_pId;
	    delete m_pRefCount;
	}
    }

    template<unsigned int GROUP, typename T> T UID<GROUP, T>::getNumber() const
    {
	return *m_pId;
    }

    template<unsigned int GROUP, typename T> void UID<GROUP, T>::invalidate()
    {
	if (isValid())
	{
	    open.push_back(*m_pId);
	    *m_pId = InvalidID;
	}
    }

    template<unsigned int GROUP, typename T> bool UID<GROUP, T>::isValid() const
    {
	return *m_pId < next;
    }

    template<unsigned int GROUP, typename T> bool UID<GROUP, T>::checkValid(T id)
    {
	return id < next && std::find(open.begin(), open.end(), id) == open.end();
    }

    template<unsigned int GROUP, typename T> T UID<GROUP, T>::getNext()
    {
	if(open.empty())
	{
	    if (next >= std::numeric_limits<T>::max())
		throw std::overflow_error("No more unique identifiers left.");

	    next++;
	    return next - 1;
	}
	else
	{
	    T use = open.back();
	    open.pop_back();
	    return use;
	}
    }

    template<unsigned int GROUP, typename T> T UID<GROUP, T>::tryUse(T id)
    {
	if(id >= next)
	{
	    // ID must not be too big.
	    if (id >= std::numeric_limits<T>::max())
		throw std::overflow_error("ID out of bounds.");

	    // Push unused IDs between current next and id to open list.
	    for(T cur = next; cur < id; cur++)
		open.push_back(cur);
	    next = id + 1;
	    return id;
	}
	else
	{
	    // ID must be in open list
	    for(auto it = open.begin(); it != open.end(); ++it)
	    {
		if(*it == id)
		{
		    open.erase(it);
		    return id;
		}
	    }
	    throw std::runtime_error("ID " + std::to_string(id) + " already taken.");
	}
    }
}

