//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template<typename Data, typename Point> unsigned int KdTree<Data, Point>::compareAxis = 0;
    
    template<typename Data, typename Point> bool KdTree<Data, Point>::compare(Container const& a, Container const& b)
    {
    	return a.point[compareAxis] <= b.point[compareAxis];
    }

    template<typename Data, typename Point> KdTree<Data, Point>::KdTree()
	{
	}
    
    template<typename Data, typename Point> template<class RandomAccessIterator> KdTree<Data, Point>::KdTree(
    		RandomAccessIterator begin,	RandomAccessIterator end)
	{
    	m_pRoot = buildTree(begin, end, 0, nullptr);
	}
    
    template<typename Data, typename Point> KdTree<Data, Point>::~KdTree()
    {
    	// Free all nodes
    	if (m_pRoot != nullptr)
		    free(m_pRoot);
    }
    
    template<typename Data, typename Point> void KdTree<Data, Point>::free(Node* node)
    {
    	if(node->leftChild != nullptr)
    		free(node->leftChild);
    	if(node->rightChild != nullptr)
    		free(node->rightChild);
    	delete node;
    	node = nullptr;
    }
    
    template<typename Data, typename Point> template<class RandomAccessIterator> auto KdTree<Data, Point>::buildTree(
    		RandomAccessIterator begin, RandomAccessIterator end, unsigned int curDepth, Node* parent) -> Node*
    {
    	// Chose median by axis as pivot element. This will result in a well-balanced tree.
    	auto amountOfElements = std::distance(begin, end);
    	if(amountOfElements > 0)
    	{
	    	// Select axis for splitting plane
	    	auto axis = curDepth % Point::getDimension();
	    	compareAxis = axis;
			auto middleElement = amountOfElements / 2;
			std::nth_element(begin, begin + middleElement, end, compare);
			auto container = *(begin + middleElement);
			// Create node and subtree
			auto node = new Node();
			node->point = container.point;
			node->data = container.data;
			node->parent = parent;
			// Recursively create subtrees
			node->leftChild = buildTree(begin, begin + middleElement, curDepth + 1);
			node->rightChild = buildTree(begin + (middleElement + 1), end, curDepth + 1);
			return node;
    	}
    	else
    		return nullptr;
    }
    
    template<typename Data, typename Point> Data* KdTree<Data, Point>::get(Point const& point)
    {
    	auto result = searchFor(point, m_pRoot, 0);
    	if(result != nullptr)
    	    return &result->data;
    	else
    		return nullptr;
    }
    
    template<typename Data, typename Point> auto KdTree<Data, Point>::searchFor(
    		Point const& point, Node* node, unsigned int curDepth, unsigned int *level) -> Node*
	{
	    if(node != nullptr)
	    {
	    	// Check if the start node is already matching
	    	if(point == node->point)
	    	{
	    		if(level != nullptr)
	    		    *level = curDepth;
	    		return node;
	    	}
	    	// Otherwise check child nodes
	    	auto axis = curDepth % Point::getDimension();
	    	if(point[axis] <= node->point[axis])
	    		return searchFor(point, node->leftChild, curDepth + 1, level);
	    	else
	    		return searchFor(point, node->rightChild, curDepth + 1, level);
	    }
	    else
	    	return nullptr;
	}
    
    template<typename Data, typename Point> void KdTree<Data, Point>::insert(
    		Point const& point, Data const& data)
    {
    	if(m_pRoot != nullptr)
    	    insert(point, data, *m_pRoot, 0);
    	else
    	{
    		m_pRoot = new Node();
    		m_pRoot->point = point;
    		m_pRoot->data = data;
    	}
    }
    
    template<typename Data, typename Point> auto KdTree<Data, Point>::insert(
    		Point const& point, Data const& data, Node& node, unsigned int curDepth) -> Node&
    {
    	auto axis = curDepth % Point::getDimension();
    	// Check if we can insert here
    	if(point[axis] <= node.point[axis] && node.leftChild == nullptr)
    	{
    		node.leftChild = new Node();
    		node.leftChild->point = point;
			node.leftChild->data = data;
			node.leftChild->parent = &node;
			return *node.leftChild;
    	}
    	else if(point[axis] > node.point[axis] && node.rightChild == nullptr)
    	{
    		node.rightChild = new Node();
    		node.rightChild->point = point;
			node.rightChild->data = data;
			node.rightChild->parent = &node;
			return *node.rightChild;
    	}
		// Otherwise check child nodes
		if(point[axis] <= node.point[axis])
			return insert(point, data, *node.leftChild, curDepth + 1);
		else
			return insert(point, data, *node.rightChild, curDepth + 1);
    }
    
    template<typename Data, typename Point> bool KdTree<Data, Point>::remove(Point const& point)
    {
    	// Check if the node to delete exists
    	unsigned int level;
    	auto node2Delete = searchFor(point, m_pRoot, 0, &level);
    	if(node2Delete == nullptr)
    		return false;
    	else
    	{
    		// It exists, thus collect all of its children and rebuild the partial tree from them
    		auto children = getAllChildren(*node2Delete);
    		auto parent = node2Delete->parent;
    		Node** attachHere = &m_pRoot;
    		if(parent != nullptr)
    		{
    			if(parent->leftChild == node2Delete)
    			    attachHere = &parent->leftChild;
    			else
    				attachHere = &parent->rightChild;
    		}   
    		free(node2Delete);
    		*attachHere = buildTree(children.begin(), children.end(), level);
    		return true;
    	}
    }
    
    template<typename Data, typename Point> auto KdTree<Data, Point>::getAllChildren(
    		Node const& node) -> std::vector<Container>
	{
	    std::vector<Container> nodes;
	    if(node.leftChild != nullptr)
	    {
	    	auto children = getAllChildren(*node.leftChild);
		    nodes.insert(nodes.end(), children.begin(), children.end());
	    }
	    if(node.rightChild != nullptr)
	    {
	    	auto children = getAllChildren(*node.rightChild);
	    	nodes.insert(nodes.end(), children.begin(), children.end());
	    }
	    nodes.push_back({node.point, node.data});
	    return nodes;
	}
}