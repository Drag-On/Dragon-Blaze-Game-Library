//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template <typename T> ResourceManager<T>::ResourceManager()
    {

    }

    template <typename T> ResourceManager<T>::~ResourceManager()
    {
	// Delete all resources
	for(unsigned int i = 0; i < m_resources.size(); i++)
	{
	    delete m_resources[i];
	}
    }

    template <typename T> ResourceHandle ResourceManager<T>::add(std::string filename)
    {
	// Check for validity of filename
	if(filename.empty())
	    return InvalidHandle;
	// Check if element already exists
	ResourceHandle handle = getHandle(filename);
	if(handle != InvalidHandle)
	    return handle;
	// Create resource
	T* resource = new T{filename}; // TODO: handle this differently
	// Add it
	handle = addNew(resource);
	// Create shortcut for filename
	m_fileNameMap[filename] = handle;
	return handle;
    }

    template <typename T> template <typename Iterator> void ResourceManager<T>::add(Iterator begin, Iterator end)
    {
	// Resize vector to hold all the new resource
	m_resources.reserve(m_resources.size() + std::distance(begin, end));
	// Add all new elements
	for(auto it = begin; it != end; ++it)
	    add(*it);
    }

    template <typename T> bool ResourceManager<T>::checkExist(std::string filename) const
    {
	return isValid(getHandle(filename));
    }

    template <typename T> bool ResourceManager<T>::checkExist(ResourceHandle handle) const
    {
	return isValid(handle);
    }

    template <typename T> ResourceHandle ResourceManager<T>::getHandle(std::string filename) const
    {
	if(m_fileNameMap.count(filename) > 0)
	    return m_fileNameMap.at(filename);
	return InvalidHandle;
    }

    template <typename T> T* ResourceManager<T>::request(std::string filename, bool forceLoad)
    {
	return request(getHandle(filename), forceLoad);
    }

    template <typename T> T* ResourceManager<T>::request(ResourceHandle handle, bool forceLoad)
    {
	if(isValid(handle))
	{
	    // Increment reference counter
	    m_resources[handle]->m_refCount++;
	    // Has it already been loaded?
	    if(!m_resources[handle]->isLoaded())
	    {
		// Force load now?
		if(forceLoad)
		    m_resources[handle]->load();
		else
		    m_needProcHandles.insert(handle);
	    }
	    return m_resources[handle];
	}
	return nullptr;
    }

    template <typename T> bool ResourceManager<T>::release(std::string filename)
    {
	return release(getHandle(filename));
    }

    template <typename T> bool ResourceManager<T>::release(ResourceHandle handle)
    {
	if(isValid(handle))
	{
	    if(m_resources[handle]->m_refCount > 0)
		m_resources[handle]->m_refCount--;
	    if (m_resources[handle]->m_refCount == 0)
		m_needProcHandles.insert(handle);
	    return true;
	}
	return false;
    }

    template <typename T> bool ResourceManager<T>::remove(std::string filename)
    {
	return remove(getHandle(filename));
    }

    template <typename T> bool ResourceManager<T>::remove(ResourceHandle handle)
    {
	if(isValid(handle))
	{
	    T * resource = m_resources[handle];
	    m_fileNameMap.erase(resource->getFilename());
	    delete resource;
	    m_resources[handle] = nullptr;
	    m_needProcHandles.erase(std::find(m_needProcHandles.begin(), m_needProcHandles.end(), handle));
	    m_openHandles.push(handle);
	    return true;
	}
	return false;
    }

    template <typename T> bool ResourceManager<T>::needLoad() const
    {
	return !m_needProcHandles.empty();
    }

    template <typename T> void ResourceManager<T>::loadNext()
    {
	if(m_needProcHandles.empty())
	    return;
	auto it = m_needProcHandles.begin();
	if(m_resources[*it]->m_refCount > 0)
	    m_resources[*it]->load();
	else
	    m_resources[*it]->unload();
	m_needProcHandles.erase(it);
    }

    template <typename T> unsigned int ResourceManager<T>::size() const
    {
	return m_resources.size() - m_openHandles.size();
    }

    template <typename T> ResourceHandle ResourceManager<T>::newHandle()
    {
	ResourceHandle handle = InvalidHandle;
	if(!m_openHandles.empty())
	{
	    handle = m_openHandles.top();
	    m_openHandles.pop();
	}
	else
	{
	    handle = m_resources.size();
	}
	return handle;
    }

    template <typename T> ResourceHandle ResourceManager<T>::addNew(T* res)
    {
	// Get a fresh handle
	ResourceHandle handle = newHandle();
	if(handle == InvalidHandle)
	    throw(ResourceException("Unable to acquire a new resource handle."));
	res->m_handle = handle;
	if(handle < m_resources.size())
	    m_resources[handle] = res;
	else
	    m_resources.push_back(res);
	return handle;
    }

    template <typename T> bool ResourceManager<T>::isValid(ResourceHandle handle) const
    {
	return(handle < m_resources.size() && m_resources[handle] != nullptr);
    }
}
