//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2014 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
    template<typename T> PoolAllocator<T>::PoolAllocator(unsigned long long size) : m_size{size}
    {
	// Check if pointers fit into the pool (for list of free blocks)
	if(sizeof(T*) > sizeof(T))
	    throw std::invalid_argument("Allocated objects must at least have the size of a pointer to that object!");

	m_pMemory = operator new(size * sizeof(T));
	// Initialize free list by writing the pointer to the next block into each block
	for(unsigned int i = 0; i < size - 1; i++)
	{
	    T** ppBlock = reinterpret_cast<T**>(reinterpret_cast<T*>(m_pMemory) + i);
	    T* pNextBlock = reinterpret_cast<T*>(m_pMemory) + i + 1;
	    *ppBlock = pNextBlock;
	}
	// Write nullptr into last block
	T** ppLastBlock = reinterpret_cast<T**>(reinterpret_cast<T*>(m_pMemory) + size-1);
	*ppLastBlock = nullptr;
	// Point m_pFreeList to first allocated block
	m_pFreeList = reinterpret_cast<T**>(m_pMemory);

	// TODO: Remove debug output
	debugOut();
    }

    template<typename T> PoolAllocator<T>::~PoolAllocator()
    {
	operator delete(m_pMemory);
    }

    template<typename T> T* PoolAllocator<T>::allocate()
    {
	// Check if there is a free block
	if(!m_pFreeList)
	    return nullptr;
	// Get the pointer to the next free block
	T** pNextFree = reinterpret_cast<T**>(*m_pFreeList);
	// Allocate object in free block
	T* obj = new (reinterpret_cast<T*>(m_pFreeList)) T {};
	// Point free list start to new start
	m_pFreeList = pNextFree;

	debugOut();
	return obj;
    }

    template<typename T> void PoolAllocator<T>::deallocate(T*& obj)
    {
	if(obj < m_pMemory || obj > reinterpret_cast<T*>(m_pMemory) + m_size || (obj - reinterpret_cast<T*>(m_pMemory)) % sizeof(T) != 0)
	    throw std::invalid_argument("Pointer doesn't point to an object within the pool.");
	// Call destructor
	obj->~T();
	// Re-insert deallocated block into free list


	debugOut();
	//..
	obj = nullptr;
    }

    template<typename T> void PoolAllocator<T>::debugOut()
    {
	// TODO: Remove debug output
	std::cout << "sizeof(T): " << sizeof(T) << std::endl;
	std::cout << "m_pMemory: " << static_cast<void*>(m_pMemory) << std::endl;
	std::cout << "m_pFreeList: " << static_cast<void*>(m_pFreeList) << std::endl;
	for(unsigned int i = 0; i < m_size; i++)
	    std::cout << "Element " << i << ": " << reinterpret_cast<T*>(*reinterpret_cast<T**>((static_cast<T*>(m_pMemory) + i))) << std::endl;
    }
}
