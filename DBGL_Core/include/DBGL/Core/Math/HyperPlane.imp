//////////////////////////////////////////////////////////////////////
/// Dragon Blaze Game Library
///
/// Copyright (c) 2015 by Jan Moeller
///
/// This software is provided "as-is" and does not claim to be
/// complete or free of bugs in any way. It should work, but
/// it might also begin to hurt your kittens.
//////////////////////////////////////////////////////////////////////

namespace dbgl
{
	template<typename T, unsigned int D> HyperPlane<T, D>::HyperPlane(Vector<T, D> const& base, Vector<T, D> const& normal)
			: m_base { base }, m_normal { normal }
	{
	}

	template<typename T, unsigned int D> Vector<T, D>& HyperPlane<T, D>::normal()
	{
		return m_normal;
	}

	template<typename T, unsigned int D> Vector<T, D>& HyperPlane<T, D>::base()
	{
		return m_base;
	}

	template<typename T, unsigned int D> bool HyperPlane<T, D>::intersects(HyperPlane<T, D> const& other) const
	{
		return m_normal.getNormalized().cross(other.m_normal.getNormalized()) != Vector<T, D>() || getDistance(other.m_base) == 0;
	}

	template<typename T, unsigned int D> T HyperPlane<T, D>::getDistance(Vector<T, D> const& point) const
	{
		return std::abs(getSignedDistance(point));
	}

	template<typename T, unsigned int D> T HyperPlane<T, D>::getSignedDistance(Vector<T, D> const& point) const
	{
		return m_normal * point - m_normal * m_base;
	}
}
